<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: cudf::detail::groupby Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="structcudf_1_1detail_1_1groupby.html">groupby</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structcudf_1_1detail_1_1groupby-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cudf::detail::groupby Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper class for computing sort-based groupby.  
 <a href="structcudf_1_1detail_1_1groupby.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="src_2quantiles_2groupby_8hpp_source.html">groupby.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a37917bd0de349c04d340efd45626eec2"><td class="memItemLeft" align="right" valign="top"><a id="a37917bd0de349c04d340efd45626eec2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_vector</b> = rmm::device_vector&lt; gdf_size_type &gt;</td></tr>
<tr class="separator:a37917bd0de349c04d340efd45626eec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade19c0651ecc426ed411cfd3ef623295"><td class="memItemLeft" align="right" valign="top"><a id="ade19c0651ecc426ed411cfd3ef623295"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bitmask_vector</b> = rmm::device_vector&lt; bit_mask::bit_mask_t &gt;</td></tr>
<tr class="separator:ade19c0651ecc426ed411cfd3ef623295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b84a814afe9e05867e8de346c3f999"><td class="memItemLeft" align="right" valign="top"><a id="ad9b84a814afe9e05867e8de346c3f999"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>gdf_col_pointer</b> = std::unique_ptr&lt; <a class="el" href="structgdf__column__.html">gdf_column</a>, std::function&lt; void(<a class="el" href="structgdf__column__.html">gdf_column</a> *)&gt; &gt;</td></tr>
<tr class="separator:ad9b84a814afe9e05867e8de346c3f999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fd045adf9d3dec48ed6bc145583781"><td class="memItemLeft" align="right" valign="top"><a id="a89fd045adf9d3dec48ed6bc145583781"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_vec_pointer</b> = std::unique_ptr&lt; index_vector &gt;</td></tr>
<tr class="separator:a89fd045adf9d3dec48ed6bc145583781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7996e32836ad71d644f563a8388681fa"><td class="memItemLeft" align="right" valign="top"><a id="a7996e32836ad71d644f563a8388681fa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bitmask_vec_pointer</b> = std::unique_ptr&lt; bitmask_vector &gt;</td></tr>
<tr class="separator:a7996e32836ad71d644f563a8388681fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aadbda679806618c3893e6e5db731c034"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#aadbda679806618c3893e6e5db731c034">groupby</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;keys, bool include_nulls=false, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:aadbda679806618c3893e6e5db731c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new groupby object.  <a href="structcudf_1_1detail_1_1groupby.html#aadbda679806618c3893e6e5db731c034">More...</a><br /></td></tr>
<tr class="separator:aadbda679806618c3893e6e5db731c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40e3aa79f9816f336ecb34aa5be08e3"><td class="memItemLeft" align="right" valign="top"><a id="af40e3aa79f9816f336ecb34aa5be08e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>groupby</b> (<a class="el" href="structcudf_1_1detail_1_1groupby.html">groupby</a> const &amp;)=delete</td></tr>
<tr class="separator:af40e3aa79f9816f336ecb34aa5be08e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc428cd39dc5bf83902c0648f987122"><td class="memItemLeft" align="right" valign="top"><a id="adbc428cd39dc5bf83902c0648f987122"></a>
<a class="el" href="structcudf_1_1detail_1_1groupby.html">groupby</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="structcudf_1_1detail_1_1groupby.html">groupby</a> const &amp;)=delete</td></tr>
<tr class="separator:adbc428cd39dc5bf83902c0648f987122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215174c555e6b9f6f03c96a86d8884e4"><td class="memItemLeft" align="right" valign="top"><a id="a215174c555e6b9f6f03c96a86d8884e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>groupby</b> (<a class="el" href="structcudf_1_1detail_1_1groupby.html">groupby</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a215174c555e6b9f6f03c96a86d8884e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d64a5c291407a8f7cc8d4826628af6"><td class="memItemLeft" align="right" valign="top"><a id="a67d64a5c291407a8f7cc8d4826628af6"></a>
<a class="el" href="structcudf_1_1detail_1_1groupby.html">groupby</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="structcudf_1_1detail_1_1groupby.html">groupby</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a67d64a5c291407a8f7cc8d4826628af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84764cec174388024eff36765a33f300"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgdf__column__.html">gdf_column</a>, rmm::device_vector&lt; gdf_size_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#a84764cec174388024eff36765a33f300">sort_values</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;values)</td></tr>
<tr class="memdesc:a84764cec174388024eff36765a33f300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups a column of values according to <code>keys</code> and sorts within each group.  <a href="structcudf_1_1detail_1_1groupby.html#a84764cec174388024eff36765a33f300">More...</a><br /></td></tr>
<tr class="separator:a84764cec174388024eff36765a33f300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7819b1ae90675495bede67ee1389a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#acb7819b1ae90675495bede67ee1389a6">unique_keys</a> ()</td></tr>
<tr class="memdesc:acb7819b1ae90675495bede67ee1389a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a table of sorted unique keys.  <a href="structcudf_1_1detail_1_1groupby.html#acb7819b1ae90675495bede67ee1389a6">More...</a><br /></td></tr>
<tr class="separator:acb7819b1ae90675495bede67ee1389a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ad9b3f6352b753b16b632aaba4e4bb"><td class="memItemLeft" align="right" valign="top">gdf_size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#ab7ad9b3f6352b753b16b632aaba4e4bb">num_groups</a> ()</td></tr>
<tr class="memdesc:ab7ad9b3f6352b753b16b632aaba4e4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of groups in <code>keys</code>  <a href="structcudf_1_1detail_1_1groupby.html#ab7ad9b3f6352b753b16b632aaba4e4bb">More...</a><br /></td></tr>
<tr class="separator:ab7ad9b3f6352b753b16b632aaba4e4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b3d5b2367404fb7efb81325ddf617"><td class="memItemLeft" align="right" valign="top">gdf_size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#a520b3d5b2367404fb7efb81325ddf617">num_keys</a> ()</td></tr>
<tr class="memdesc:a520b3d5b2367404fb7efb81325ddf617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the effective number of keys.  <a href="structcudf_1_1detail_1_1groupby.html#a520b3d5b2367404fb7efb81325ddf617">More...</a><br /></td></tr>
<tr class="separator:a520b3d5b2367404fb7efb81325ddf617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c277941f931e075003821e2206741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#afd7c277941f931e075003821e2206741">key_sort_order</a> ()</td></tr>
<tr class="memdesc:afd7c277941f931e075003821e2206741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sorted order of <code>keys</code>.  <a href="structcudf_1_1detail_1_1groupby.html#afd7c277941f931e075003821e2206741">More...</a><br /></td></tr>
<tr class="separator:afd7c277941f931e075003821e2206741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aa8f89be48fb4b32005273f8d8a9b4"><td class="memItemLeft" align="right" valign="top">index_vector const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#a14aa8f89be48fb4b32005273f8d8a9b4">group_offsets</a> ()</td></tr>
<tr class="memdesc:a14aa8f89be48fb4b32005273f8d8a9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get each group's offset into the sorted order of <code>keys</code>.  <a href="structcudf_1_1detail_1_1groupby.html#a14aa8f89be48fb4b32005273f8d8a9b4">More...</a><br /></td></tr>
<tr class="separator:a14aa8f89be48fb4b32005273f8d8a9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e05d524780777724a78a7f1b22bbbe6"><td class="memItemLeft" align="right" valign="top">index_vector const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1groupby.html#a0e05d524780777724a78a7f1b22bbbe6">group_labels</a> ()</td></tr>
<tr class="memdesc:a0e05d524780777724a78a7f1b22bbbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the group labels corresponding to the sorted order of <code>keys</code>.  <a href="structcudf_1_1detail_1_1groupby.html#a0e05d524780777724a78a7f1b22bbbe6">More...</a><br /></td></tr>
<tr class="separator:a0e05d524780777724a78a7f1b22bbbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper class for computing sort-based groupby. </p>
<p>This class serves the purpose of sorting the keys and values and provides building blocks for aggregations. It can provide:</p><ol type="1">
<li>On-demand grouping and sorting of a value column based on <code>keys</code> which is provided at construction</li>
<li>Group offsets: starting offsets of all groups in sorted key table</li>
<li>Group valid sizes: The number of valid values in each group in a sorted value column </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aadbda679806618c3893e6e5db731c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbda679806618c3893e6e5db731c034">&#9670;&nbsp;</a></span>groupby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudf::detail::groupby::groupby </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_nulls</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new groupby object. </p>
<p>If <code>include_nulls == false</code>, then any row in <code>keys</code> containing a null value will effectively be discarded. I.e., any values corresponding to discarded rows in <code>keys</code> will not contribute to any aggregation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>table to group by </td></tr>
    <tr><td class="paramname">include_nulls</td><td>whether to include null keys in groupby </td></tr>
    <tr><td class="paramname">stream</td><td>used for all the computation in this groupby object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e05d524780777724a78a7f1b22bbbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e05d524780777724a78a7f1b22bbbe6">&#9670;&nbsp;</a></span>group_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_vector&lt; gdf_size_type &gt; const  &amp; cudf::detail::groupby::group_labels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the group labels corresponding to the sorted order of <code>keys</code>. </p>
<p>Each group is assigned a unique numerical "label" in <code>[0, 1, 2, ... , <a class="el" href="structcudf_1_1detail_1_1groupby.html#ab7ad9b3f6352b753b16b632aaba4e4bb" title="Get the number of groups in keys">num_groups()</a> - 1, <a class="el" href="structcudf_1_1detail_1_1groupby.html#ab7ad9b3f6352b753b16b632aaba4e4bb" title="Get the number of groups in keys">num_groups()</a>)</code>. For a row in sorted <code>keys</code>, its corresponding group label indicates which group it belongs to.</p>
<p>Computes and stores labels on first invocation and returns stored labels on subsequent calls.</p>
<dl class="section return"><dt>Returns</dt><dd>vector of group labels for each row in the sorted key column </dd></dl>

</div>
</div>
<a id="a14aa8f89be48fb4b32005273f8d8a9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14aa8f89be48fb4b32005273f8d8a9b4">&#9670;&nbsp;</a></span>group_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_vector&lt; gdf_size_type &gt; const  &amp; cudf::detail::groupby::group_offsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get each group's offset into the sorted order of <code>keys</code>. </p>
<p>Computes and stores the group offsets on first invocation and returns the stored group offsets on subsequent calls.</p>
<dl class="section return"><dt>Returns</dt><dd>vector of offsets of the starting point of each group in the sorted key table </dd></dl>

</div>
</div>
<a id="afd7c277941f931e075003821e2206741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7c277941f931e075003821e2206741">&#9670;&nbsp;</a></span>key_sort_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp; cudf::detail::groupby::key_sort_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sorted order of <code>keys</code>. </p>
<p>Gathering <code>keys</code> by sort order indices will produce the sorted key table.</p>
<p>Computes and stores the key sorted order on first invocation, and returns the stored order on subsequent calls.</p>
<dl class="section return"><dt>Returns</dt><dd>the sort order indices for <code>keys</code>. </dd></dl>

</div>
</div>
<a id="ab7ad9b3f6352b753b16b632aaba4e4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ad9b3f6352b753b16b632aaba4e4bb">&#9670;&nbsp;</a></span>num_groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gdf_size_type cudf::detail::groupby::num_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of groups in <code>keys</code> </p>

</div>
</div>
<a id="a520b3d5b2367404fb7efb81325ddf617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520b3d5b2367404fb7efb81325ddf617">&#9670;&nbsp;</a></span>num_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gdf_size_type cudf::detail::groupby::num_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the effective number of keys. </p>
<p>When include_nulls = true, returned value is same as <code>keys.num_rows()</code> When include_nulls = false, returned value is the number of rows in <code>keys</code> in which no element is null </p>

</div>
</div>
<a id="a84764cec174388024eff36765a33f300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84764cec174388024eff36765a33f300">&#9670;&nbsp;</a></span>sort_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgdf__column__.html">gdf_column</a>, rmm::device_vector&lt; gdf_size_type &gt; &gt; cudf::detail::groupby::sort_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Groups a column of values according to <code>keys</code> and sorts within each group. </p>
<p>Groups the <code>values</code> where the groups are dictated by key table and each group is sorted in ascending order, with NULL elements positioned at the end of each group. Calculates and returns the number of valid values within each group.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>values.size != keys.num_rows()</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The value column to group and sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sorted and grouped column and per-group valid count </dd></dl>

</div>
</div>
<a id="acb7819b1ae90675495bede67ee1389a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7819b1ae90675495bede67ee1389a6">&#9670;&nbsp;</a></span>unique_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::detail::groupby::unique_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a table of sorted unique keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a new table in which each row is a unique row in the sorted key table. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="src_2quantiles_2groupby_8hpp_source.html">src/quantiles/groupby.hpp</a></li>
<li>quantiles/groupby.cu</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
